// Automatically generated by gitlab.com/hookactions/gqlgen-relay
// DO NOT EDIT

package entity

import (
	"encoding/base64"
	"fmt"

	"github.com/pkg/errors"
	"github.com/vmihailenco/msgpack"
	"gitlab.com/hookactions/gqlgen-relay/relay"
)

// CityEdge is the edge representation of City
type CityEdge struct {
	Cursor string `json:"cursor"`
	Node   *City  `json:"node"`
}

// CityConnection is the connection containing edges of City
type CityConnection struct {
	Edges      []CityEdge     `json:"edges"`
	PageInfo   relay.PageInfo `json:"pageInfo"`
	TotalCount *int           `json:"totalCount"`
}

// CityCursor is the edge representation of City
type CityCursor struct {
	Offset int    `json:"offset"`
	ID     string `json:"id"`
}

func NewCityCursor(offset int, id fmt.Stringer) *CityCursor {
	return &CityCursor{Offset: offset, ID: id.String()}
}

func EncodeCityCursor(cursor *CityCursor) string {
	b, err := msgpack.Marshal(cursor)
	if err != nil {
		panic("unable to marshal City cursor: " + err.Error())
	}
	return base64.StdEncoding.EncodeToString(b)
}

func DecodeCityCursor(cursor string) (*CityCursor, error) {
	b, err := base64.StdEncoding.DecodeString(cursor)
	if err != nil {
		return nil, errors.Wrap(err, "unable to decode cursor")
	}

	var out CityCursor
	if err := errors.Wrap(msgpack.Unmarshal(b, &out), "unable to unmarshal City cursor"); err != nil {
		return nil, err
	}
	return &out, nil
}

func MustDecodeCityCursor(cursor string) *CityCursor {
	decoded, err := DecodeCityCursor(cursor)
	if err != nil {
		panic("unable to decode City cursor: " + err.Error())
	}
	return decoded
}

var CityInvalidPagination = errors.New("City invalid pagination parameters")

type CityPaginationFunc = func(offset, limit int) (items []*City, total *int, err error)

func NewCityPage(defaultLimit int, first *int, afterCursor *string, beforeCursor *string, paginate CityPaginationFunc) (*CityConnection, error) {
	offset := 0
	limit := defaultLimit

	if first != nil {
		limit = *first
	}

	if afterCursor != nil && beforeCursor != nil {
		return nil, CityInvalidPagination
	}

	if afterCursor != nil {
		out, err := DecodeCityCursor(*afterCursor)
		if err != nil {
			return nil, err
		}

		offset = out.Offset + 1
	} else if beforeCursor != nil {
		out, err := DecodeCityCursor(*beforeCursor)
		if err != nil {
			return nil, err
		}

		offset = out.Offset - limit
	}

	page := &CityConnection{}

	items, total, err := paginate(offset, limit)
	if err != nil {
		return nil, err
	}

	for i, item := range items {
		page.Edges = append(page.Edges, CityEdge{
			Cursor: EncodeCityCursor(NewCityCursor(offset+i, item.GetID())),
			Node:   item,
		})
	}

	startCursor, endCursor := (*string)(nil), (*string)(nil)
	if len(page.Edges) > 0 {
		startCursor = relay.NewString(page.Edges[0].Cursor)
		endCursor = relay.NewString(page.Edges[len(page.Edges)-1].Cursor)
	}

	hasNextPage := false
	hasPreviousPage := offset > 0

	if total != nil {
		if afterCursor != nil {
			// we don't need to do total - 1 because of out.Offset + 1
			hasNextPage = (offset + len(items)) < *total
		} else {
			hasNextPage = (offset + len(items)) < *total-1
		}
	}

	page.PageInfo = relay.PageInfo{
		HasNextPage:     hasNextPage,
		HasPreviousPage: hasPreviousPage,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
	page.TotalCount = total

	return page, nil
}
